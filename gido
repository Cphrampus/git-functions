#!/bin/bash

usage="usage: $0 [-t -h] command file [file]
-t: test, dry run, just print what would be run
-h: display this help
filerange: comma or space separated line numbers from git status,
ranges are also supported in the form x-y, or x-
x- goes from line number x to the end, negative indices are also supported"

if [[ $# -lt 2 ]]
then
	echo "$usage"
	exit
fi

args=()

while [ "$1" ]
do
	case $1 in
		-h)
			echo "$usage"
			exit
			;;
		-t)
			dry=true
			shift
			;;
		*)
			args=(${args[@]} $1)
			shift
			;;
	esac
done

len=$(git status -s |
wc -l)

command=${args[0]}
args=(${args[@]:1})

items=$(echo "${args[@]}"			|
# deal with csv
tr ',' ' '							|
tr ' ' '\n'							|
# deal with ranges
sed 's/\([0-9]\)-\([0-9]\)/\1,\2/'	|
# deal with ranges without an end
sed 's/\([0-9]\)-/\1,$/'			|
# negative indices
awk -v len="$len" '{print ($1 < 0) ? (len + $1 + 1) : $1}'
)

for i in $items
do
	# make sure index is in range
	if [[ $i =~ [0-9]+$ && ( $i -gt $len || $i -le 0 ) ]]
	then
		echo -n "$i is out of range!"
		echo " $len changed file$([[ $len -gt 1 ]] && echo s)"
		exit
	fi
	if [[ $i =~ [0-9]+ ]]
	then
		# otherwise add to list
		indices="$indices${i}p;"
	else
		command="$command $i"
	fi
done

command="git $command $(git status -s	|
cut -c4-								|
sed -n "$indices"						|
tr '\n' ' ')"

if [[ $dry ]]
then
	echo "$command"
else
	eval "$command"
fi
